type Event @entity(immutable: true) {
  id: Bytes!
  type: EventType!
  atom: Atom
  triple: Triple
  deposit: Deposit
  redemption: Redemption
  feeTransfer: FeeTransfer
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

enum EventType {
  AtomCreated
  TripleCreated
  Deposited
  Redeemed
  FeesTransfered
}

type Atom @entity {
  id: ID!
  creator: Account!
  wallet: Account!
  uri: String!
  data: String!

  type: AtomType!
  emoji: String
  label: String
  image: String

  value: AtomValue

  vault: Vault!

  activePositionsCount: Int
  allPositionsCount: Int

  isSubject: [Triple!]! @derivedFrom(field: "subject")
  isPredicate: [Triple!]! @derivedFrom(field: "predicate")
  isObject: [Triple!]! @derivedFrom(field: "object")

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Account @entity {
  id: ID!
  label: String
  image: String
  atom: Atom
  type: AccountType!
  createdAtoms: [Atom!]! @derivedFrom(field: "creator")
  createdTriples: [Triple!]! @derivedFrom(field: "creator")
  feeTransfers: [FeeTransfer!]! @derivedFrom(field: "sender")
  deposits: [Deposit!]! @derivedFrom(field: "sender")
  redemptions: [Redemption!]! @derivedFrom(field: "sender")
  positions: [Position!]! @derivedFrom(field: "account")
  signals: [Signal!]! @derivedFrom(field: "account")
}

enum AccountType {
  Default
  AtomWallet
  ProtocolVault
}

type Triple @entity {
  id: String!
  creator: Account!
  subject: Atom!
  predicate: Atom!
  object: Atom!

  vault: Vault!
  inverseVault: Vault!

  positions: [Position!]!
  positionsCount: Int!

  inversePositions: [Position!]!
  inversePositionsCount: Int!

  activePositionsCount: Int
  allPositionsCount: Int

  "vault.totalShares + inverseVault.totalShares"
  tvl: BigInt!

  "vault.totalShares - inverseVault.totalShares"
  totalSignal: BigInt!
  signals: [Signal!]!

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

enum AtomType {
  Unknown
  JSON
  Account
  Thing
  ThingPredicate
  Person
  PersonPredicate
  Organization
  OrganizationPredicate
  Book
  LikeAction
  FollowAction
  Keywords
}

type AtomValue @entity {
  id: ID!
  account: Account
  thing: Thing
  person: Person
  organization: Organization
  book: Book
}

type Thing @entity {
  id: ID!
  atom: Atom!
  name: String
  description: String
  image: String
  url: String
}

type Person @entity {
  id: ID!
  atom: Atom!
  identifier: String
  name: String
  description: String
  image: String
  email: String
  url: String
}

type Organization @entity {
  id: ID!
  atom: Atom!
  identifier: String
  name: String
  description: String
  image: String
  email: String
  url: String
}

type Book @entity {
  id: ID!
  atom: Atom!
  name: String
  description: String
  genre: String
  url: String
}

type Deposit @entity(immutable: true) {
  id: Bytes!

  "initializer of the deposit"
  sender: Account!

  "beneficiary of the minted shares"
  receiver: Account!

  "total shares held by the receiver in the vault"
  receiverTotalSharesInVault: BigInt!

  "total assets that go towards minting shares for the receiver"
  senderAssetsAfterTotalFees: BigInt!

  "total shares transferred"
  sharesForReceiver: BigInt!

  "fee amount collected for entering the vault"
  entryFee: BigInt!

  "vault being deposited into"
  vault: Vault!

  "whether the vault is a triple vault or not"
  isTriple: Boolean!

  "whether the receiver is an atom wallet or not"
  isAtomWallet: Boolean!

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type FeeTransfer @entity(immutable: true) {
  id: Bytes!
  sender: Account!
  receiver: Account!
  amount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Redemption @entity(immutable: true) {
  id: Bytes!

  "initializer of the withdrawal (owner of the shares)"
  sender: Account!

  "beneficiary of the withdrawn assets (can be different from the sender)"
  receiver: Account!

  "total shares held by the sender in the vault"
  senderTotalSharesInVault: BigInt!

  "quantity of assets withdrawn by the receiver"
  assetsForReceiver: BigInt!

  "quantity of shares redeemed"
  sharesRedeemedBySender: BigInt!

  "total fee amount collected for exiting the vault"
  exitFee: BigInt!

  "vault being redeemed from"
  vault: Vault!

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Vault @entity {
  id: ID!
  atom: Atom
  triple: Triple
  inverse: Vault

  totalShares: BigInt!

  deposits: [Deposit!]! @derivedFrom(field: "vault")
  redemptions: [Redemption!]! @derivedFrom(field: "vault")
  positions: [Position!]! @derivedFrom(field: "vault")
}

type Position @entity {
  id: ID!
  account: Account!
  vault: Vault!
  shares: BigInt!
}

type Signal @entity {
  id: Bytes!

  delta: BigInt!

  "atom or triple (delta / tvl)"
  relativeStrength: BigInt!

  account: Account!
  atom: Atom
  triple: Triple
  deposit: Deposit
  redemption: Redemption

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type AtomSignalData @entity(timeseries: true) {
  id: Int8!
  timestamp: Timestamp!
  atom: Atom!
  account: Account!
  delta: BigInt!
}

type SignalStats
  @aggregation(intervals: ["hour", "day"], source: "AtomSignalData") {
  id: Int8!
  timestamp: Timestamp!
  atom: Atom!
  account: Account!
  totalSignal: BigInt! @aggregate(fn: "sum", arg: "delta")
  count: Int8! @aggregate(fn: "count", cumulative: true)
}
