type Event @entity(immutable: true){
  id: Bytes!
  type: EventType!
  atom: Atom
  triple: Triple
  deposit: Deposit 
  redemption: Redemption 
  feeTransfer: FeeTransfer
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

enum EventType {
  AtomCreated
  TripleCreated
  Deposited
  Redeemed
  FeesTransfered
}


type Atom @entity {
  id: ID!
  creator: Account!
  wallet: Account!
  uri: String!
  data: String!

  type: AtomType!
  emoji: String
  label: String
  image: String

  value: AtomValue

  vault: Vault!

  "todo"
  totalSignal: BigInt!
  
  signals: [Signal!]!
  
  activePositionsCount: Int
  allPositionsCount: Int

  isSubject: [Triple!]! @derivedFrom(field: "subject")
  isPredicate: [Triple!]! @derivedFrom(field: "predicate")
  isObject: [Triple!]! @derivedFrom(field: "object")

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Account @entity {
  id: ID!
  label: String
  image: String
  atom: Atom
  type: AccountType!
  createdAtoms: [Atom!]! @derivedFrom(field: "creator")
  createdTriples: [Triple!]! @derivedFrom(field: "creator")
  feeTransfers: [FeeTransfer!]! @derivedFrom(field: "sender")
  deposits: [Deposit!]! @derivedFrom(field: "sender")
  redemptions: [Redemption!]! @derivedFrom(field: "sender")
  positions: [Position!]! @derivedFrom(field: "account")
  signals: [Signal!]! @derivedFrom(field: "account")
}

enum AccountType {
  Default
  AtomWallet
  ProtocolVault
}

type Triple @entity {
  id: String!
  creator: Account!
  subject: Atom!
  predicate: Atom!
  object: Atom!


  vault: Vault!
  inverseVault: Vault!

  positions: [Position!]!
  positionsCount: Int!

  inversePositions: [Position!]!
  inversePositionsCount: Int!

  activePositionsCount: Int
  allPositionsCount: Int

  "vault.totalShares + inverseVault.totalShares"
  tvl: BigInt!

  "vault.totalShares - inverseVault.totalShares"
  totalSignal: BigInt! 
  signals: [Signal!]!

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

enum AtomType {
  Unknown
  JSON
  Account
  Person
  PersonPredicate
  Book
  LikeAction
  FollowAction
  Keywords
}

type AtomValue @entity {
  id: ID!
  account: Account
  person: Person
  book: Book
}

type Person @entity {
  id: ID!
  identifier: String
  name: String
  image: String
  email: String
  url: String
}

type Book @entity {
  id: ID!
  name: String
  genre: String
  url: String
}

type Deposit @entity(immutable: true) {
  id: Bytes!

  "initializer of the deposit"
  sender: Account! 

  "beneficiary of the minted shares"
  receiver: Account!

  "total assets held in the vault"
  vaultBalance: BigInt! 

  "total assets that go towards minting shares for the receiver"
  userAssetsAfterTotalFees: BigInt! 

  "total shares transferred"
  sharesForReceiver: BigInt!

  "fee amount collected for entering the vault"
  entryFee: BigInt! 

  "vault being deposited into"
  vault: Vault! 

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type FeeTransfer @entity(immutable: true) {
  id: Bytes!
  sender: Account! 
  receiver: Account! 
  amount: BigInt! 
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Redemption @entity(immutable: true) {
  id: Bytes!

  "initializer of the withdrawal (owner of the shares)"
  sender: Account! 

  "beneficiary of the withdrawn assets (can be different from the sender)"
  receiver: Account! 

  "total assets held in the vault"
  vaultBalance: BigInt! 

  "quantity of assets withdrawn by the receiver"
  assetsForReceiver: BigInt! 

  "quantity of shares redeemed"
  shares: BigInt! 

  "total fee amount collected for exiting the vault"
  exitFee: BigInt! 

  "vault being redeemed from"
  vault: Vault! 

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Vault @entity {
  id: ID!
  atom: Atom
  triple: Triple
  inverse: Vault

  totalShares: BigInt!

  deposits: [Deposit!]! @derivedFrom(field: "vault")
  redemptions: [Redemption!]! @derivedFrom(field: "vault")
  positions: [Position!]! @derivedFrom(field: "vault")

}

type Position @entity {
  id: ID!
  account: Account!
  vault: Vault!
  balance: BigInt!
}

type Signal @entity {
  id: Bytes!

  delta: BigInt!

  "atom or triple (delta / tvl)"
  relativeStrength: BigInt!

  account: Account!
  atom: Atom
  triple: Triple
  deposit: Deposit
  redemption: Redemption
  
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}
