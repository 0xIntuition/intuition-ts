type Event @entity(immutable: true){
  id: ID!
  type: EventType!
  atom: Atom
  triple: Triple
  deposit: Deposit 
  redemption: Redemption 
  feeTransfer: FeeTransfer
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

enum EventType {
  AtomCreated
  TripleCreated
  Deposited
  Remeemed
  FeesTransfered
}


type Atom @entity {
  id: ID!
  creator: Account!
  wallet: Bytes!
  uri: String!
  data: String!

  type: AtomType!
  emoji: String
  label: String
  image: String

  value: AtomValue

  vault: Vault!

  "same as atom.vault.balance"
  tvl: BigInt! 

  "same as atom.tvl"
  totalSignal: BigInt!
  
  signals: [Signal!]!
  
  activePositionsCount: Int
  allPositionsCount: Int

  isSubject: [Triple!]! @derivedFrom(field: "subject")
  isPredicate: [Triple!]! @derivedFrom(field: "predicate")
  isObject: [Triple!]! @derivedFrom(field: "object")

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Account @entity {
  id: ID!
  label: String
  image: String
  createdAtoms: [Atom!]! @derivedFrom(field: "creator")
  createdTriples: [Triple!]! @derivedFrom(field: "creator")
  feeTransfers: [FeeTransfer!]! @derivedFrom(field: "sender")
  deposits: [Deposit!]! @derivedFrom(field: "sender")
  redemptions: [Redemption!]! @derivedFrom(field: "sender")
  positions: [Position!]! @derivedFrom(field: "account")
  signals: [Signal!]! @derivedFrom(field: "account")
}

type Triple @entity {
  id: String!
  creator: Account!
  subject: Atom!
  predicate: Atom!
  object: Atom!


  vault: Vault!
  inverseVault: Vault!

  positions: [Position!]!
  positionsCount: Int!

  inversePositions: [Position!]!
  inversePositionsCount: Int!

  activePositionsCount: Int
  allPositionsCount: Int

  "vault.balance + inverseVault.balance"
  tvl: BigInt!

  "vault.balance - inverseVault.balance"
  totalSignal: BigInt! 
  signals: [Signal!]!

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

enum AtomType {
  Unknown
  JSON
  Person
  Book
  LikeAction
  FollowAction
  Keywords
}

type AtomValue @entity {
  id: ID!
  person: Person
  book: Book
}

type Person @entity {
  id: ID!
  identifier: String
  name: String
  image: String
  email: String
  url: String
}

type Book @entity {
  id: ID!
  name: String
  genre: String
  url: String
}

type Deposit @entity(immutable: true) {
  id: Bytes!
  sender: Account! 
  receiver: Account!
  vaultBalance: BigInt! 
  userAssetsAfterTotalFees: BigInt! 
  sharesForReceiver: BigInt! 
  entryFee: BigInt! 
  vault: Vault! 
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type FeeTransfer @entity(immutable: true) {
  id: Bytes!
  sender: Account! 
  protocolVault: Bytes! 
  amount: BigInt! 
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Redemption @entity(immutable: true) {
  id: Bytes!
  sender: Account! 
  receiver: Account! 
  vaultBalance: BigInt! 
  assetsForReceiver: BigInt! 
  shares: BigInt! 
  exitFee: BigInt! 
  vault: Vault! 
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Vault @entity {
  id: ID!
  atom: Atom
  triple: Triple
  inverse: Vault

  balance: BigInt!

  deposits: [Deposit!]! @derivedFrom(field: "vault")
  redemptions: [Redemption!]! @derivedFrom(field: "vault")
  positions: [Position!]! @derivedFrom(field: "vault")

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Position @entity {
  id: ID!
  account: Account!
  vault: Vault!
  balance: BigInt!
}

type Signal @entity {
  id: ID!

  delta: BigInt!

  "atom or triple (delta / tvl)"
  relativeStrength: Int!

  account: Account!
  atom: Atom
  triple: Triple
  deposit: Deposit
  redemption: Redemption
  
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}
